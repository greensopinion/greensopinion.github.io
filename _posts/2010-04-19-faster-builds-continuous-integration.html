---
layout: post
title: 'Faster Builds: A Continuous Integration Build Strategy'
date: '2010-04-19T15:00:00.000-07:00'
author: David Green
tags:
- Hudson
- Continuous Integration
- Ant
modified_time: '2010-04-20T14:59:22.798-07:00'
thumbnail: http://3.bp.blogspot.com/_vw9l2nnub6c/S84iuYcBeXI/AAAAAAAAAM8/vKBe-d2lmp0/s72-c/Screen+shot+2010-04-20+at+2.54.35+PM.png
blogger_id: tag:blogger.com,1999:blog-1482979278030787271.post-1387559005709101925
original_url: http://greensopinion.blogspot.com/2010/04/faster-builds-continuous-integration.html
---

<p>We all know that <a href="http://en.wikipedia.org/wiki/Continuous_integration">Continuous Integration (CI)</a> can deliver real, tangible benefits to our projects.  So why are the benefits so elusive?  Many software projects claim to be exercising CI, but have builds that run for 30 minutes or more, or worse, just have a nightly build.  Build times that exceed a few minutes are excessive; all too commonly we see build times reaching 20 minutes to an hour or two.  Real projects tend to have build times that gradually increase as the project evolves, resulting in a failure to reach the full potential that CI promises to deliver.  Luckily for many of these projects, there's a solution that can get your project back on track.</p><a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://3.bp.blogspot.com/_vw9l2nnub6c/S84iuYcBeXI/AAAAAAAAAM8/vKBe-d2lmp0/s1600/Screen+shot+2010-04-20+at+2.54.35+PM.png"><img style="display:block; margin:0px auto 10px; text-align:center;cursor:pointer; cursor:hand;width: 400px; height: 255px;" src="http://3.bp.blogspot.com/_vw9l2nnub6c/S84iuYcBeXI/AAAAAAAAAM8/vKBe-d2lmp0/s400/Screen+shot+2010-04-20+at+2.54.35+PM.png" border="0" alt=""id="BLOGGER_PHOTO_ID_5462341578276305266" /></a><p>I've seen many projects with this problem, and they all have the same pattern: a monolithic build that builds components in a serial fashion.  While many of these projects are modular, where modules can be built independently, dependencies between modules prevent them from being built in parallel.</p><p>So how do we get shorter build times?  We cheat.</p><p>By building modules in independent CI jobs, we can get faster feedback for independent modules of our project without reducing the total build time.  As we make discrete changes to the source code, only the affected modules will rebuild.</p><p>With this approach each module is built separately from the others.  As a result we get very fast feedback as to the impact of our changes, possibly even before downstream modules have finished building.  Furthermore, in many cases only part of the project will need building &mdash; thus resulting in a reduction in total build time.  I know, I said that total build time is not reduced using this approach, but for many cases the total build time is in fact reduced since we don't always need to build the whole project!</p><p>So how do we employ this approach in practice?  These are the steps that I took on a recent project:</p><ol><li>Identify logical modules of related functionality in your project.  For Eclipse projects, this could be related plug-ins.  For my project which involves about 100 Eclipse plug-ins (OSGi bundles) this meant splitting the bundles into about 7 modules.</li><li>Next, change your build process so that each module builds independently.  To do this I started with the module that would need to be built without any dependencies on other modules.  After creating a CI job to built it, I moved on to the next module, which could now download its dependencies from the first CI job.  Repeat this process until each module is built by an independent CI job that downloads its dependencies as binaries from other CI jobs.</li><li>After all modules were building on the CI server using binary dependencies, some minor tweaks were required to limit job concurrency and unnecessary thrashing on the build server.  This is where the power of <a href="http://hudson-ci.org">Hudson</a> really shines.<ol><li>Configure each module's job under <b>Post-build Actions</b> to trigger the next module in the series of dependant modules: check <b>Build other projects</b> and list them there.</li><li>Using the <a href="http://wiki.hudson-ci.org/display/HUDSON/Locks+and+Latches+plugin">Locks and Latches plugin</a> ensure that all module jobs are using the same lock, preventing them from all building at once.</li></ol></li></ol><p>Here's what I ended up with:</p><p><b>Before:</b> 1 job, 1100 tests, 30 minute build time.</p><p><b>After:</b> 7 jobs, 1075 tests, 20 minute 30 second build time, with a break down as follows in dependency order:</p><table width="auto" style="width:auto;"><tr style="border:1px;"><td>Job 1:</td><td>20 seconds</td></tr><tr><td>Job 2:</td><td>26 seconds</td></tr><tr><td>Job 3:</td><td>1 minute 31 seconds</td></tr><tr><td>Job 4:</td><td>5 minutes 54 seconds</td></tr><tr><td>Job 5:</td><td>5 minutes 45 seconds</td></tr><tr><td>Job 6:</td><td>5 minutes 12 seconds</td></tr><tr><td>Job 7:</td><td>1 minute 12 seconds</td></tr></table><p>The net result is that most of the time, <em>we get feedback within 6 minutes</em>, whereas we were having to wait 30 minutes.  Even if you can't parallelize your build, splitting your build into independent modules that build serially can produce measurable benefits such as faster feedback and shorter build times.</p>