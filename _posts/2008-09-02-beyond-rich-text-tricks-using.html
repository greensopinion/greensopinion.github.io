---
layout: post
title: 'Beyond Rich Text:  Tricks Using SourceViewer, Annotations and AnnotationPainter'
date: '2008-09-02T08:36:00.000-07:00'
author: David Green
tags: 
modified_time: '2008-09-02T09:10:44.131-07:00'
thumbnail: http://4.bp.blogspot.com/_vw9l2nnub6c/SL1fIXv3JDI/AAAAAAAAABo/4GWMMFdPvww/s72-c/Picture+1.png
blogger_id: tag:blogger.com,1999:blog-1482979278030787271.post-1391405770367614885
original_url: http://greensopinion.blogspot.com/2008/09/beyond-rich-text-tricks-using.html
---

<div><br />An SWT StyledText can display text attributes such as bold, italic and strikethrough, alter colors and fonts.  What are we to do when we need to go beyond rich text formatting?  In this article we present three simple tricks using standard SWT and JFace APIs to create a polished presentation where text attributes alone won't do the job.</div><br /><h2 style="color:black">Marking The Spot</h2><br /><div>In order to display something interesting, we need to mark the spot.  Normally this is done with a TextPresentation, which specifies character offsets and style ranges.  Fortunately the Eclipse APIs give us another mechanism to mark regions of text in an extensible manner: annotations.</div><br /><div>The key APIs at our disposal are as follows:<br /></div><div><br /><code>org.eclipse.jface.text.source.Annotation</code><br /><code>org.eclipse.jface.text.source.AnnotationModel</code><br /></div><br /><div>Using these APIs we can create annotations and specify their location.  An easy place to do this is in your document partitioner.  It will be called at the appropriate times to partition your document.  By using a <code>RuleBasedPartitionScanner</code> you can modify your rules to create the appropriate annotations.</div><br /><div>Now that our document is annotated, we know where we need to draw.  To hook up the drawing strategy, we add the following code to the initialization of the SourceViewer:</div><br /><pre><code><br />IAnnotationAccess annotationAccess = new IAnnotationAccess() {<br />public Object getType(Annotation annotation) {<br />    return annotation.getType();<br />}<br />public boolean isMultiLine(Annotation annotation) {<br />    return true;<br />}<br />public boolean isTemporary(Annotation annotation) {<br />    return true;<br />}<br />};<br /><br />AnnotationPainter painter = new AnnotationPainter(sourceViewer, annotationAccess);<br /></code></pre><br /><div><br />Now all we have to do is add a drawing strategy to the painter for every kind of annotation that we're interested in drawing.  Read on to find out how we do that.<div><br /><h2 style="color:black">Repainting Characters</h2><br /><div>Not all fonts can display all characters.  This is problematic in an application that is internationalized or one where the user can change the font.<br /></div><br /><div>Take for example bullets.  Unicode <code>\u2022</code> can be used to display a solid round bullet with most fonts, but what about an empty one, or a square one?  These characters cannot be reliably found in commonly used fonts.  The trick we use is to always use the <code>\u2022</code> character, but repaint it where we want to display something more interesting.  By doing that we get the display just right and the text works nicely with copy/paste operations.<br /></div><br /><div>To make it work, we create annotations where our bullet characters are in the document.  We then hook up a bullet drawing strategy to our painter as follows:</div><br /><pre><code><br />painter.addDrawingStrategy(BulletAnnotation.TYPE, new BulletDrawingStrategy());<br />painter.addAnnotationType(BulletAnnotation.TYPE, BulletAnnotation.TYPE);<br />painter.setAnnotationTypeColor(BulletAnnotation.TYPE, getTextWidget().getForeground());<br /></code></pre><br /><div>The painter won't invoke our drawing strategy unless the type and type color are also added.<br /></div><br /><div>What does our bullet annotation look like?  It needs to have enough information for the drawing strategy to know what to draw.  In this case the shape of the bullet is dependent on the 'level' of indentation.  Here's what I used:</div><br /><pre><code><br /><br />public class BulletAnnotation extends Annotation {<br /><br />public static final String TYPE = "org.eclipse.mylyn.internal.wikitext.ui.viewer.annotation.bullet";<br /><br />private final int indentLevel;<br /><br />public BulletAnnotation(int indentLevel) {<br />super(TYPE, false, Integer.toString(indentLevel));<br />this.indentLevel = indentLevel;<br />}<br /><br />public int getIndentLevel() {<br />return indentLevel;<br />}<br /><br />}<br /></code></pre><br /><div><br />Now we need to implement our drawing strategy.  The drawing strategy must 'erase' the existing bullet character and then draw the new bullet shape where the old bullet was.<br /></div><br /><div>We erase the previous character by drawing a rectangle the size of the character in the background color:<br /></div><br /><pre><code><br />// erase whatever character was there<br />gc.fillRectangle(left.x, left.y, right.x - left.x, lineHeight);<br /></code></pre><br /><div><br />then we draw the new shape:<br /></div><br /><pre><code><br />// now paint the bullet<br />switch (bullet.getIndentLevel()) {<br />case 1: // round solid bullet<br /> gc.setBackground(color);<br /> gc.fillOval(hcenter - 3, vcenter - 2, 5, 5);<br /> break;<br />case 2: // round empty bullet<br /> gc.setForeground(color);<br /> gc.drawOval(hcenter - 3, vcenter - 3, 5, 5);<br /> break;<br />default: // square bullet<br /> gc.setBackground(color);<br /> gc.fillRectangle(hcenter - 3, vcenter - 2, 5, 5);<br /> break;<br />}<br /></code></pre><br /><div><br />Here's a screenshot showing an example of this technique in use:<br /></div><br /><a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://4.bp.blogspot.com/_vw9l2nnub6c/SL1fIXv3JDI/AAAAAAAAABo/4GWMMFdPvww/s1600-h/Picture+1.png"><img style="display:block; margin:0px auto 10px; text-align:center;cursor:pointer; cursor:hand;" src="http://4.bp.blogspot.com/_vw9l2nnub6c/SL1fIXv3JDI/AAAAAAAAABo/4GWMMFdPvww/s400/Picture+1.png" border="0" alt="" id="BLOGGER_PHOTO_ID_5241450138747479090" /></a><br /><h2 style="color:black">Drawing Non-Characters</h2><br /><div>Sometimes there's a need to display non-characters.  For example, browsers display a horizontal line for &lt;hr /&gt; (horizontal rule).  By marking the spot with annotations and registering a custom painter, we can do the same thing.  Here's the result we're looking for.<br /></div><br /><a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://2.bp.blogspot.com/_vw9l2nnub6c/SL1fz_LHdlI/AAAAAAAAABw/UqKLpUMk_ic/s1600-h/Picture+2.png"><img style="display:block; margin:0px auto 10px; text-align:center;cursor:pointer; cursor:hand;" src="http://2.bp.blogspot.com/_vw9l2nnub6c/SL1fz_LHdlI/AAAAAAAAABw/UqKLpUMk_ic/s400/Picture+2.png" border="0" alt="" id="BLOGGER_PHOTO_ID_5241450888065152594" /></a><br /><div><br />To create this effect we put an empty line in the text we're displaying and annotate it with a HorizontalRuleAnnotation.   Drawing the annotation is easy:<br /></div><br /><pre><code><br /><br />public void draw(Annotation annotation, GC gc, StyledText textWidget, int offset, int length, Color color) {<br />if (gc != null) {<br />final Color foreground = gc.getForeground();<br /><br />Point left = textWidget.getLocationAtOffset(offset);<br />Point right = textWidget.getLocationAtOffset(offset + length);<br />if (left.x > right.x) {<br /> // hack: sometimes linewrapping text widget gives us the wrong x/y for the first character of a line that<br /> // has been wrapped.<br /> left.x = 0;<br /> left.y = right.y;<br />}<br />right.x = textWidget.getClientArea().width;<br /><br />int baseline = textWidget.getBaseline(offset);<br /><br />int vcenter = left.y + (baseline / 2) + (baseline / 4);<br /><br />gc.setLineWidth(0); // NOTE: 0 means width is 1 but with optimized performance<br />gc.setLineStyle(SWT.LINE_SOLID);<br /><br />left.x += 3;<br />right.x -= 5;<br />vcenter -= 2;<br /><br />if (right.x > left.x) {<br /> // draw the shadow<br /> gc.setForeground(shadowForeground);<br /> gc.drawRectangle(left.x, vcenter, right.x - left.x, 2);<br /><br /> // draw the horizontal rule<br /> gc.setForeground(color);<br /> gc.drawLine(left.x, vcenter, right.x, vcenter);<br /> gc.drawLine(left.x, vcenter, left.x, vcenter + 2);<br />}<br /><br />gc.setForeground(foreground);<br />} else {<br />textWidget.redrawRange(offset, length, true);<br />}<br />}<br /></code></pre><br /><div><br />As before, we hook the drawing strategy up to the painter:<br /></div><br /><pre><code><br />  painter.addDrawingStrategy(HorizontalRuleAnnotation.TYPE, new HorizontalRuleDrawingStrategy());<br />  painter.addAnnotationType(HorizontalRuleAnnotation.TYPE, HorizontalRuleAnnotation.TYPE);<br />  painter.setAnnotationTypeColor(HorizontalRuleAnnotation.TYPE,  getTextWidget().getForeground());<br /></pre></code><br /><h2 style="color:black">Conclusion</h2><br /><div><br />Eclipse provides some powerful APIs for hooking into the painting of StyledText.  Using some simple tricks we can create powerful polished visuals in an SWT user interface.  All of these techniques are applied in the <a href="http://wiki.eclipse.org/Mylyn/Incubator/WikiText">Mylyn WikiText</a> project, where you can find source code that works.<br /></div></div></div>