---
layout: imported-post
title: Evolving a Wiki Markup Parser
date: '2008-04-02T12:43:00.001-07:00'
author: David Green
tags:
- MediaWiki
- Java
- wiki
- Textile
- Confluence
- markup languges
modified_time: '2008-04-02T12:52:22.189-07:00'
thumbnail: http://1.bp.blogspot.com/_vw9l2nnub6c/R_PiEBCjcnI/AAAAAAAAABA/crP_MQNnlpo/s72-c/parser-architecture.png
blogger_id: tag:blogger.com,1999:blog-1482979278030787271.post-624753225023702389
blogger_orig_url: http://greensopinion.blogspot.com/2008/04/evolving-wiki-markup-parser.html
---

Initially my <a href="https://textile-j.dev.java.net/">Textile-J open-source project</a> started out with modest goals: to provide a <a href="http://en.wikipedia.org/wiki/Textile_%28markup_language%29">Textile markup</a> parser for Java.  Since the project has started, interest in other features drove evolution of the code-base in some interesting directions.  This article discusses architectural choices and the evolution of the Textile-J parser architecture to meet changing requirements.<div><div><br /></div><div>The initial design of the Textile-J parser was a monolithic stateful parser class that used regular expressions and local variables to parse the markup.  The results of parsing markup were passed to the XMLStreamWriter interface as HTML elements and attributes.  This architecture worked fine initially, as it allowed me to evolve my understanding of Textile markup structure (blocks, phrases and tokens) and the XMLStreamWriter provided a solid means of outputting XHTML.</div><div><br /></div><div><b>Feature: Multiple Output Formats</b></div><div><br /></div><div>The first major feature request was to support multiple output formats: HTML and <a href="http://www.docbook.org/">DocBook</a>.  This required a major rethink of the parser.  While XMLStreamWriter was a great means of outputting XML, the parser had to know that HTML was the output format.  After some thinking and reviewing the ever-relevant <a href="http://en.wikipedia.org/wiki/Design_Patterns">GOF Design Patterns book</a>, I recognized that the Builder design pattern was an ideal fit.  So I created a new interface called DocumentBuilder, with an HtmlDocumentBuilder and DocbookDocumentBuilder implementations.  Now the parser need not know about the output format, meaning that a single parser could drive multiple output formats.</div><div><br /></div><div><b>Feature: Markup Dialects</b></div><div><br /></div><div>Next extensions to the Textile markup language were requested.  For example, <a href="http://en.wikipedia.org/wiki/Atlassian_Confluence">Confluence</a> markup dialect is very similar to Textile but has some additional syntax features.  With a better understanding of markup structure (blocks, phrases and tokens) I designed a new 'Dialect' concept that allowed for markup extensions to be added to the base Textile language.  The 'Dialect' design was object-oriented, making extensions modular and relatively easy to add without disturbing the base markup parser code.</div><div><br /></div><div><b>Feature: Markup Languages</b></div><div><br /></div><div>While the approach of markup dialects worked well for adding extensions to Textile parsing, it did not solve the problem of fully supporting new markup languages.  Dialects at this point were only capable of extending Textile.  </div><div><br /></div><div>Community demand for supporting new markup languages was increasing, including requests for <a href="http://en.wikipedia.org/wiki/MediaWiki">MediaWiki</a> and <a href="http://en.wikipedia.org/wiki/Markdown">Markdown</a>.  Supporting these languages was not possible using the existing Textile parser, as the markup rules of Textile were embedded in a single monolithic class.  After some prolonged hesitation (this would be a big job), I got down to the design of a complete rewrite of the parser architecture.</div><div><br /></div><div>The first step was to read up on various markup languages.  Most languages that I've looked at use a simple line-based parsing approach that consists of dividing the markup into blocks, phrases and tokens.  Blocks are usually multi-line constructs that have certain attributes, such as paragraphs and lists.  Phrases are modifiers that affect text on a single line, and tokens are match-and-replace elements in the text.</div><div><br /></div><div>Requirements of the new design had to include:</div><div><ul><li>ease of adding new markup languages</li><li>modular object-oriented design for better maintainability</li><li>facilitate comprehensive JUnit tests</li><li>easier learning curve for community contributions</li><li>pluggable architecture</li><li>output format agnostic</li></ul></div><div>Using my experience with the previous Dialect design here's what I came up with:</div><div><br /></div><div><br /><a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://1.bp.blogspot.com/_vw9l2nnub6c/R_PiEBCjcnI/AAAAAAAAABA/crP_MQNnlpo/s1600-h/parser-architecture.png"><img style="margin: 0px auto 10px; display: block; text-align: center; cursor: pointer;" src="http://1.bp.blogspot.com/_vw9l2nnub6c/R_PiEBCjcnI/AAAAAAAAABA/crP_MQNnlpo/s400/parser-architecture.png" alt="" id="BLOGGER_PHOTO_ID_5184736154660074098" border="0" /></a><br /></div><div><br /></div><div>The parser delegates all language-specific parsing to the Dialect.  The Dialect defines a language with a collection of Blocks, phrase modifiers (PatternBasedElement) and tokens (PatternBasedElement).  Blocks implement rules specific to paragraphs, lists, tables, etc.  Concrete PatternBasedElementProcessor classes know how to emit portions of content affected by markup (phrase modifiers or tokens).</div><div><br /></div><div>So far the following languages have been imlemented using this new architecture:</div><div><ul><li>Textile</li><li>MediaWiki (a la <a href="http://www.wikipedia.org/">WikiPedia</a> fame)</li><li>Confluence</li></ul><div>I hope to see contributions from the community for supporting <a href="http://en.wikipedia.org/wiki/Lightweight_markup_language">other languages</a>, such as Markdown and Creole.</div></div><br /></div>