---
layout: post
title: 'How I Lost My Annotations: JPA, Hibernate and FetchType.LAZY'
date: '2009-09-03T08:00:00.000-07:00'
author: David Green
tags:
- Java
- JPA
- Hibernate
modified_time: '2009-09-03T10:18:16.787-07:00'
blogger_id: tag:blogger.com,1999:blog-1482979278030787271.post-132544505299283721
original_url: http://greensopinion.blogspot.com/2009/08/how-i-lost-my-annotations-jpa-hibernate.html
---

<p>Many <a href="http://en.wikipedia.org/wiki/Java_Persistence_API">JPA</a> applications use Java annotations on their domain model classes in order to specify validation rules.  Runtime frameworks use reflection to discover these validation rules and enforce them at runtime.  This all works nicely until you realize that you need <code>FetchType.LAZY</code> on some of your @ManyToOne associations.  After specifying lazy fetching you may find that some of your annotations disappear – only not all the time.  So what's going on here?  This article discusses the implications of <code>FetchType.LAZY</code> and how to overcome this intermittent problem.</p><p></p><p>In order to implement lazy fetching under the covers Hibernate enhances your classes.  What does this mean?  Basically, Hibernate extends your classes and overrides its methods at runtime.  It does this by using one of two bytecode manipulation libraries: <a href="http://www.csg.is.titech.ac.jp/~chiba/javassist/">Javassist</a> or <a href="http://cglib.sourceforge.net/">CGLib</a>.  If you ask one of these enhanced classes for its name, you'll end up with something like this:</p><pre><br />// JPA entity class name<br />greensopinion.Person<br /><br />// CGLib enhanced class name<br />greensopinion.Person$$EnhancerByCGLIB$$4ad0592d<br /><br />// Javassist enhanced class name<br />greensopinion.Person_$$_javassist_0<br /></pre><p>Hibernate only does this when necessary.  So when you get an instance of your entity it might be enhanced, and it might not – depending on how it was loaded.  This can be confusing, since instances of a Person may not always be the same class.  For example, code like this can be problematic:</p><pre><code><br />Person person1 = entityManager.find(Person.class,id1);<br />Person person2 = entityManager.find(Person.class,id2);<br /><br />// bad: contrary to what we'd expect, this comparison may<br />// be true sometimes, but not always<br />if (person1.getClass() == person2.getClass()) {<br />}<br />// bad: this may not work as expected either<br />if (person1.getClass().isAssignableFrom(person2.getClass())) {<br />}<br />// bad: again, sometimes true sometimes false<br />if (person1.getClass().isAssignableFrom(Person.class)) {<br />}<br />// this is ok: comparison will always be true (assuming person1 is not null)<br />if (person1 instanceof Person) {<br />}<br /></code></pre><p>In the above example comparisons that look straight-forward may behave differently depending on how and if these entities were already loaded by the same entity manager.  This can be tricky when implementing <a href="http://opensource.atlassian.com/projects/hibernate/browse/HHH-3771">hashCode and equals</a>.</p><p>Furthermore, we're in for more trouble if we declare Person as follows:</p><pre><code><br />@Entity<br />public class Person {<br /><br />  ...<br /><br />  @Required<br />  public String getFirstName() { ... }<br /><br />}<br /></code></pre><p>Here we're using an annotation to indicate to our validation framework that the firstName property is a required field (see <a href="http://jcp.org/en/jsr/detail?id=303">JSR-303</a>, <a href="https://www.hibernate.org/412.html">Hibernate Validation</a>, <a href="https://springmodules.dev.java.net/">Spring Modules</a>, <a href="http://oval.sourceforge.net/">OVal</a>).  Our validation framework may do something like this:</p><pre><code><br />Class clazz = entity.getClass();<br /><br />// iterate on class accessors<br />...<br /><br />if (method.getAnnotation(Required.class) != null) {<br />  ...<br />}<br /></code></pre><p>This may work well most of the time, and may work in all of our unit tests – however in the running application it may appear as if our class has lost its annotations!  Why is this happening?  Don't worry, your JVM isn't losing its head, or your annotations.  This code may not work as expected if our entity is an enhanced version since Hibernate's ProxyFactory enhancers <a href="http://opensource.atlassian.com/projects/hibernate/browse/HHH-4112">don't consider annotations when overriding methods</a> on your entity.</p><p>So why use <code>FetchType.LAZY</code> at all?  Most non-trivial <a href="http://en.wikipedia.org/wiki/Java_Persistence_API">JPA</a> applications will have to make use of <code>FetchType.LAZY</code> in order to avoid @ManyToOne associations from causing cascading loads.  Using <code>FetchType.LAZY</code> can also reduce the number of joins when fetching collections, which in some cases greatly improves performance.</p><p>So how to we solve this problem?  Our reflection code must be aware of HibernateProxy.  Here's an example of how this can be fixed:</p><pre><code><br /><br />Class clazz = PersistenceUtil.getEntityClass(entity);<br />... now do reflection ...<br /><br />// in PersistenceUtil.java<br />public static Class getEntityClass(Object entity) {<br />   if (entity instanceof HibernateProxy) {<br />       return ((HibernateProxy)entity).getHibernateLazyInitializer().getPersistentClass();<br />   }<br />   return entity.getClass();<br />}<br /></code></pre><p>The intermittent and in some cases occasional nature of the symptoms involved make this problem hard to reproduce.  Lazy fetching may seem like a panacea, however it's another case where <a href="http://en.wikipedia.org/wiki/Leaky_abstraction">leaky abstractions</a> make our lives more challenging.  As with most things in software development, it's important to understand the implementation details in order to work effectively with JPA.</p>