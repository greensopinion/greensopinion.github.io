---
layout: post
title: Key Bindings in Eclipse Editors
date: '2009-10-27T12:23:00.000-07:00'
author: David Green
tags:
- Eclipse
modified_time: '2009-10-27T13:30:27.778-07:00'
blogger_id: tag:blogger.com,1999:blog-1482979278030787271.post-363912190097070724
x_original_url: http://greensopinion.blogspot.com/2009/10/key-bindings-in-eclipse-editors.html
comments: true
---

<p>For tool writers, the Eclipse platform provides great facilities for binding keys to commands so that specific actions can be invoked with the right key combination.  In most cases hooking into these facilities is a simple matter of activating the right context via <code>IContextService</code> and using a few extension points in your <tt>plugin.xml</tt>.  For more complex editors, such as those with multiple Text or StyledText controls, it's not so easy.  This article examines the mechanisms that the Eclipse platform uses to determine how commands are handled, and outlines an approach for implementing editors that wish to alter command handling depending on the focus control.</p><p>Suppose we are building an editor that has more than one StyledText control and uses <tt>IOperationHistory</tt> to support undo/redo.  We want CTRL+Z and CTRL+Y (Command-Z and Command-Y on a Mac) to cause undo/redo in the editor.  In this editor what we want is for these keys to manipulate the <tt>IOperationHistory</tt>, however when a StyledText has focus in our editor we want to invoke undo/redo on the StyledText.  In other words, the user will expect undo/redo to behave differently depending on what they're doing.  This is consistent with how undo/redo work throughout the rest of the platform.</p><p>Eclipse uses the following abstractions to represent the concept  of keys invoking commands:</p><ul><li>KeyBinding - binds a sequence of keys to a logical command</li><li>Command - an abstract representation for some semantic behaviour</li><li>IHandler - an implementation of the behaviour for a specific command</li></ul><p>Let's take (for example) CTRL+Z.  When key presses are made, they are matched with a <tt>KeyBinding</tt>.  Eclipse knows which <tt>Command</tt> to invoke based on the <tt>KeyBinding</tt> (in this case the 'undo' command).  Eclipse then determines which <tt>IHandler</tt> to use by looking up the handler using the logical command in <tt>IHandlerService</tt>.  (There are many layers of indirection in the actual implementation -- this example is simplified for ease of understanding).</p><p>In our editor we want the operation history to be associated with undo/redo.  We hook it up as follows:</p><pre><code><br />OperationHistoryActionHandler undoAction= new UndoActionHandler(site, moduleEditor.getOperationContext());<br />PlatformUI.getWorkbench().getHelpSystem().setHelp(undoAction, IAbstractTextEditorHelpContextIds.UNDO_ACTION);<br />undoAction.setActionDefinitionId(IWorkbenchActionDefinitionIds.UNDO);<br />undoAction.setId(ITextEditorActionConstants.UNDO);<br /><br />IHandlerService handlerService = (IHandlerService) site.getService(IHandlerService.class);<br />handlerService.activateHandler(undoAction.getActionDefinitionId(), new ActionHandler(undoAction));<br /></code></pre><p>When we test our editor this works as expected: we can undo changes in the editor by pressing CTRL+Z.  After focusing on a StyledText in our editor however, we expect CTRL+Z to undo text that we type.  In our editor these text changes aren't in our operation history until after the text control loses focus.  So how do we set that up?  Here's how:</p><pre><code><br />TextViewer textViewer = // create the text viewer<br />TextViewerSupport support = new TextViewerSupport(textViewer);<br /></code></pre><p>Most of the work is done by this helper class:</p><pre><code><br /><br /> protected class TextViewerSupport implements FocusListener, DisposeListener {<br /><br />  private final TextViewer textViewer;<br />  private List<IHandlerActivation> handlerActivations = new ArrayList<IHandlerActivation>();<br />  <br /><br />  public TextViewerSupport(TextViewer textViewer) {<br />   this.textViewer = textViewer;<br />   StyledText textWidget = textViewer.getTextWidget();<br />   textWidget.addFocusListener(this);<br />   textWidget.addDisposeListener(this);<br /><br />   if (textViewer.getTextWidget().isFocusControl()) {<br />    activateContext();<br />   }<br />  }<br />  public void focusLost(FocusEvent e) {<br />   deactivateContext();<br />  }<br />  public void focusGained(FocusEvent e) {<br />   activateContext();<br />  }<br />  public void widgetDisposed(DisposeEvent e) {<br />   deactivateContext();<br />  }<br /><br />  protected void activateContext() {<br />   if (handlerActivations.isEmpty()) {<br />    activateHandler(ISourceViewer.QUICK_ASSIST,ITextEditorActionDefinitionIds.QUICK_ASSIST);<br />    activateHandler(ISourceViewer.CONTENTASSIST_PROPOSALS,ITextEditorActionDefinitionIds.CONTENT_ASSIST_PROPOSALS);<br />    activateHandler(ITextOperationTarget.CUT, ITextEditorActionDefinitionIds.CUT);<br />    activateHandler(ITextOperationTarget.COPY, ITextEditorActionDefinitionIds.COPY);<br />    activateHandler(ITextOperationTarget.PASTE, ITextEditorActionDefinitionIds.PASTE);<br />    activateHandler(ITextOperationTarget.DELETE, ITextEditorActionDefinitionIds.DELETE);<br />    activateHandler(ITextOperationTarget.UNDO, ITextEditorActionDefinitionIds.UNDO);<br />    activateHandler(ITextOperationTarget.REDO, ITextEditorActionDefinitionIds.REDO);<br />   }<br />  }<br />  <br /><br />  protected void activateHandler(int operation, String actionDefinitionId) {<br />   StyledText textWidget = textViewer.getTextWidget();<br />   IHandler actionHandler = createActionHandler(operation, actionDefinitionId);<br />   IHandlerActivation handlerActivation = handlerService.activateHandler(actionDefinitionId, actionHandler,new ActiveFocusControlExpression(textWidget));<br />   <br />   handlerActivations.add(handlerActivation);<br />  }<br /><br />  private IHandler createActionHandler(final int operation, String actionDefinitionId) {<br />   Action action = new Action() {<br />    @Override<br />    public void run() {<br />     if (textViewer.canDoOperation(operation)) {<br />      textViewer.doOperation(operation);<br />     }<br />    }<br />   };<br />   action.setActionDefinitionId(actionDefinitionId);<br />   return new ActionHandler(action);<br />  }<br />  <br />  protected void deactivateContext() {<br />   if (!handlerActivations.isEmpty()) {<br />    for (IHandlerActivation activation: handlerActivations) {<br />     handlerService.deactivateHandler(activation);<br />     activation.getHandler().dispose();<br />    }<br />    handlerActivations.clear();<br />   }<br />  }  <br /> }<br /></code></pre><p>Though <tt>TextViewerSupport</tt> looks complicated, it's really just activating different command handlers whenever the textViewer gains focus.</p><p>When the text control has focus the editor now has two handlers for the undo command.  So how does Eclipse know which one to use?  Digging into the internals of Eclipse reveals that it uses the handler with highest priority.  But we don't set a priority no these handlers!  Eclipse calculates the priority of handlers automatically based on the enablement expression of the handler.  The priority of the enablement expression is based in part on the variables that the expression references.  This leads us to the last part of our solution, <tt>ActiveFocusControlExpression</tt>:</p><pre><code><br />/**<br /> * An expression that evaluates to true if and only if the current focus control is the one provided.<br /> * Has a very high priority in order to ensure proper conflict resolution.<br /> */<br />public class ActiveFocusControlExpression extends Expression {<br /><br /> private Control focusControl;<br /><br /> public ActiveFocusControlExpression(Control control) {<br />  focusControl = control;<br /> }<br /><br /> @Override<br /> public void collectExpressionInfo(ExpressionInfo info) {<br />  info.markDefaultVariableAccessed(); // give it a very high priority<br />  info.addVariableNameAccess(ISources.ACTIVE_SHELL_NAME);<br />  info.addVariableNameAccess(ISources.ACTIVE_WORKBENCH_WINDOW_NAME);<br /> }<br /><br /> @Override<br /> public EvaluationResult evaluate(IEvaluationContext context)<br />   throws CoreException {<br />  if (Display.getCurrent() != null && focusControl.isFocusControl()) {<br />   return EvaluationResult.TRUE;<br />  }<br />  return EvaluationResult.FALSE;<br /> }<br />}</code></pre><p>In <tt>collectExpressionInfo</tt> we ensure that the expression indicates that it uses the default variable.  This gives the expression a very high priority.  Since the expression is only enabled when our control has focus, we've ensured that undo is directed to our text control at the right time.</p><p><em>Credit:</em> The approach described in this article is inspired by a class <tt>CommonTextSupport</tt> (authored by Steffen Pingel) from the <a href="http://www.eclipse.org/mylyn">Mylyn</a> project.</p>
