---
layout: post
title: Eclipse GUI Testing Is Viable With SWTBot
date: '2008-09-23T20:49:00.000-07:00'
author: David Green
tags:
- Java
- testing
- JUnit
- SWTBot
- GEF
- Eclipse
- UI
- DSL
modified_time: '2008-09-23T21:08:29.758-07:00'
blogger_id: tag:blogger.com,1999:blog-1482979278030787271.post-4270813416718277945
x_original_url: http://greensopinion.blogspot.com/2008/09/eclipse-gui-testing-is-viable-with.html
comments: true
---

<div>For several years I've struggled with the viability of automated Eclipse GUI test frameworks.  Now for the first time I've found an approach that works reliably.  This article discusses the approach and details some specific techniques that greatly increase productivity in creating useful tests.</div><br /><div>In the past automated GUI test frameworks have failed to meet my needs because they have focused too much on recording and playback.  The complexity of the Eclipse environment makes it near impossible to get this approach to work reliably.  Simple things such as background jobs and processing become major issues.  Testing of GEF-based editors is not possible since all record/playback frameworks rely on identifying controls and widgets -- which GEF does not use.</div><br /><div>Recently I've come across <a href="http://www.swtbot.org/">SWTBot</a>, which uses a novel approach.  SWTBot tests are written in Java, and run inside the Eclipse process as an Eclipse test application.  This gives SWTBot full access to the SWT and Eclipse APIs.  SWTBot tests are written as JUnits, which makes integration with common technologies such as Ant, Continuous Integration and code coverage tools easy.</div><br /><div>But all is not rosy when writing tests with SWTBot.  There are some Eclipse-specific idiosyncrasies that come back to bite you such as context menus that are reconstructed when shown and the GEF framework that does not use controls or widgets.  That said, SWTBot provides and excellent starting point.  Here's how I built on SWTBot to create a powerful test environment that is easy to use.</div><br /><div>Initially my tests contained code that looks like this:</div><br /><pre><code><br />public void resetPerspective() {<br />bot.menu("Window").menu("Reset Perspective...").click();<br />bot.shell("Reset Perspective").activate();<br />bot.button("OK").click();<br />}<br /></code></pre><br /><div>Not bad!  It's easy to see what's going on.  In other cases the code looked more like this:</div><br /><code></code><pre><code><br />SWTBotTree tree = bot.tree();<br />String[] path = name.split("/");<br />SWTBotTreeItem[] items = tree.getAllItems();<br />SWTBotTreeItem selectedItem = null;<br />for (SWTBotTreeItem item: items) {<br />if (path[0].equals(item.getText())) {<br />item.expand();<br />sleep();<br />selectedItem = item;<br />break;<br />}<br />}<br />for (int x = 1;selectedItem != null &amp;&amp; x<path.length;++x) string="" pathitem="path[x];" selecteditem="selectedItem.getNode(pathItem);" if="" throw="" new="" cannot="" select="" tree="" segment=""></path.length;++x)></code></pre><br /><div>As you can see, it's hard to see the forest for the trees.  Way too much code is required to do simple things.</div><br /><div>Here's what I did to make things easier:</div><br /><div><b>1. Create classes that directly model the UI parts that you're working with in your tests.</b>  For example, instead of directly using SWTBotView to manipulate the Package Explorer view, create a class called PackageExplorer that delegates to SWTBotView and provides richer functionality.  For example, in my PackageExplorer class I have the following method:</div><br /><pre><code><br />/**<br />* select the first element that adapts to the given resource<br />*/<br />public void select(final IResource resource)<br /></code></pre><br /><div><b>2. Create a method to find and click context menu items in one go.</b>  In SWTBot the finding and clicking occur in two seperate UI runnables.  In Eclipse this can cause problems for some context menus as the menu item gets disposed before it is clicked due to a loss of focus.</div><br /><div><b>3. Instead of using sleep() to wait for something to be done, wait for the real thing to be done.</b>  A heavily loaded machine can cause processing times to vary.  Instead of having a fragile sleep(500L), use a reliable technique to determine when the job is really done.</div><div>For example, if you know that your processing is holding a resource lock, post a no-op empty workspace job and wait on it inside your test.  It will only be invoked once all other resource locks are released, so when it's complete you're guaranteed that your other job is done:</div><br /><pre><code><br />// ensure that all queued workspace operations and locks are released<br />ResourcesPlugin.getWorkspace().run(new IWorkspaceRunnable() {<br />public void run(IProgressMonitor monitor) throws CoreException {<br />// nothing to do!<br />}<br />}, new NullProgressMonitor());<br /></code></pre><br /><div><b>4. Leverage and extend the SWTBot framework with Eclipse-specific behaviour.</b>  For example, make use of SWTBot's conditional waiting APIs by creating Eclipse-specific conditions like this one that is used to wait until an editor is opened on a resource:</div><br /><pre><code><br />/**<br />* a condition that is used to wait for an editor to open on a specific file.<br />*<br />* @author dgreen<br />*/<br />public class EditorOpenCondition extends DefaultCondition {<br />private final IFile file;<br /><br />public EditorOpenCondition(IFile file) {<br />this.file = file;<br />}<br /><br />public String getFailureMessage() {<br />return String.format("Timed out waiting for editor on %s to open",file.getFullPath());<br />}<br /><br />public boolean test() throws Exception {<br />if (!file.exists()) {<br />return false;<br />}<br />return UIThreadRunnable.syncExec(new UIThreadRunnable.BoolResult() {<br />public boolean run() {<br />IEditorReference[] editorReferences = PlatformUI.getWorkbench().getActiveWorkbenchWindow().getActivePage().getEditorReferences();<br />for (IEditorReference reference: editorReferences) {<br /> try {<br />  IEditorInput input = reference.getEditorInput();<br />  if (input instanceof IFileEditorInput) {<br />   IFileEditorInput editorInput = (IFileEditorInput) input;<br />   if (editorInput.getFile().equals(file)) {<br />    return true;<br />   }<br />  }<br />  if (input instanceof IStorageEditorInput) {<br />   IStorageEditorInput editorInput = (IStorageEditorInput) input;<br />   IPath fullPath = editorInput.getStorage().getFullPath();<br />   if (fullPath.equals(file.getFullPath())) {<br />    return true;<br />   }<br />  }<br /> } catch (PartInitException e) {<br />  e.printStackTrace();<br /> } catch (CoreException e) {<br />  e.printStackTrace();<br /> }<br />}<br />return false;<br />}<br />});<br />}<br />}<br /></code></pre><br /><div><b>5. Create a Java-based DSL for often-repeated use of editors or views.</b>  For example, for a static class diagram editor you might end up with a DSL that could be used as follows:</div><br /><pre><code><br />DomainModelDsl domainModelDsl = new DomainModelDsl();<br />domainModelDsl.create(project, "domain.dm");<br /><br />domainModelDsl.<br />createEntity("A").<br />createEntity("B");<br /><br />domainModelDsl.entity("A").extension("B");<br /></code></pre><br /><div>Inside the DSL implementation the dirty work of manipulating the editor occurs.  This makes it really fast to create complex tests that cover lots of ground.</div><br /><div><b>6. Create GEF EditPart wappers.</b>  For GEF-based editors SWTBot doesn't give a lot of lift.  For these you'll need to create classes similar to those provided by SWTBot, but instead of being widget-focused, they'll need to be EditPart-focused.</div><br /><div>All in all I'm very impressed with SWTBot, which has finally delivered a viable automated GUI test framework for Eclipse and Eclipse RCP applications.  I'm pleased to see that SWTBot has made an <a href="http://www.eclipse.org/proposals/swtbot/">Eclipse project proposal</a>, which if approved will hopefully lead to continued improvements and community adoption.</div>
