---
layout: post
title: 'Android versus iPhone Development: A Comparison'
date: '2009-07-02T23:01:00.001-07:00'
author: David Green
tags:
- Java
- Eclipse
- Android
- XCode
- iPhone
modified_time: '2009-07-03T07:50:00.456-07:00'
thumbnail: http://3.bp.blogspot.com/_vw9l2nnub6c/Sk2e-j6p2NI/AAAAAAAAAHU/KzoZ58wkpVY/s72-c/content-assist-javadoc.png
blogger_id: tag:blogger.com,1999:blog-1482979278030787271.post-5669151997714898459
original_url: http://greensopinion.blogspot.com/2009/07/android-versus-iphone-development.html
comments: true
---

<p>A few months ago I ventured into the world of Mobile development and created an application (<a href="http://greensopinion.blogspot.com/2009/05/hudson-helper-hudson-on-your-iphone.html">Hudson Helper</a>) for both iPhone and Android.  This article is about my experiences, comparing Android and iPhone development with a focus on tools, platform and the developer experience.</p><p>Before going much further I should note that my comparison is with considerable bias.  I’ve spent the past 12+ years in Java development, having spent much of my career building developer tools.  Since January of 2004 I’ve been building plug-ins for <a href="http://www.eclipse.org/">Eclipse</a>, and before that plug-ins for <a href="http://www.netbeans.org/">NetBeans</a>.  This bias is somewhat tempered with several years of C and C++ development.  With this background I find that I’m very critical of developer tools.  Developer productivity is key — anything that takes away from the flow of a developer in the zone is a real problem.</p><h4 id="LanguageProgrammingModelandPlatform">Language, Programming Model and Platform</h4><h5 id="Language">Language</h5><p>The language of choice for iPhone development is <a href="http://en.wikipedia.org/wiki/Objective-C">Objective-C</a>.  Objective-C is a language based on C with extensions for object-oriented concepts, such as classes, inheritance, interfaces, messages, dynamic typing, etc.  The Java language is used when developing for Android (though it doesn’t actually get compiled to bytecode).  </p><p>Java is a no-brainer.  I have to say that it’s nice not to have to learn a new language to target mobile.  Existing skillsets don’t come easy — so reuse of expertise is worth a lot.</p><p>It took a little while to wrap my head around some of the language features available with Objective-C.  I soon discovered that I really loved certain language features, such as message passing (instead of calling methods), categories and named arguments.   I did find however that the syntax of Objective-C is cumbersome.  I’m still not used to ‘+’ and ‘-’ for static and member methods, too many parentheses are required, and in general I just felt like I had to type way to much to express a simple concept.  The IDE didn’t help much with this either (more on that later).</p><p>One thing that really became clear to me is that Objective-C, though it may have been visionary for its time, is really a language of the '80s.  Certain issues such as split header and implementation files and violation of <a href="http://en.wikipedia.org/wiki/DRY">DRY</a> are really time-wasters, and not small ones at that.  I found myself constantly switching back and forth between files, which not only has a cost in navigation (which file to open?) but with every file opened your sense of context must be recreated (where’s the caret, what’s selected, where am I in the file, how is this file organized).  </p><p>As far as DRY, must I really do 5 things to declare a property?? (declare in the class definition, again to declare getter/settter, initialize in the init method, @synthesize in the implementation, release in dealloc).  Here’s what I mean:</p><p><b>Server.h</b></p><pre><code><br />@interface Server : Updatable {<br />NSString *name;  &lt;-- declare the property <br />}<br /><br />@property (nonatomic,retain) NSString *name; &lt;--- declare the property again<br /><br /></code></pre><p><b>Server.m</b></p><pre><code><br />@synthesize name;  &lt;-- implement getter/setter<br /><br />-(void) dealloc {<br />[name release];  &lt;-- release memory<br />}<br /><br /></code></pre><p>If you ask me, everything in Server.m should go away.  Another gotcha here is the positional relevance of @synthesize.</p><p>Java has a similar problem with properties, though not quite so bad — and the IDE helps you write your getter/setter.       </p><p>Pointers in Objective-C, though powerful, are also another time-waster.  This is where Java really shines with its garbage collection.  I found that I was constantly considering whether allocated objects were freed appropriately.  Code flow is poor since application logic is littered with memory management.  I only have so many brain cycles available — why do I have to think about this other cruft that’s not really a core concern of the application domain?  Of course this gets even worse when trying to figure out where things went wrong if you make a mistake.  Zombies help, but still don’t make it obvious if you’ve accessed something that was deallocated.   Other issues include deallocating something twice, autoreleasing something twice.  I also found it non-intuitive when to retain return values from methods.</p><p>Another annoyance of Objective-C is the patterns that must be followed: implementing correct init and dealloc methods is non-trivial.   @synthesized getters and setters for properties with retain should not be called in these methods.  So many conventions and rules to remember!</p><p>Though I understand why there’s a separation of alloc and init, it’s still overly wordy to specify <code>[[aloc Foo] initWithArg: arg]</code>.  Why not just <code>[new Foo arg]</code>?  Or how about <code>new Foo(arg)</code> -- oh, wait, that’s just like Java!</p><p>Objective-C’s imports and forward-declarations (@class) are a pain.  Though these issues exist with Java development, Eclipse’s JDT is so good that I’ve almost forgotten what it’s like to write an import.  All you have to do is Ctrl+Space to auto-complete a class name or Ctrl+Shift+O to organize imports and voila!</p><p>Of course Java is not perfect either, however this fact is hidden from me due to the fact that I’ve been living in Java for a very long time.  Sometimes I wish that Java were more <a href="http://en.wikipedia.org/wiki/Groovy_(programming_language)">Groovy</a>-like, however I’m used to it and the tooling is so good.</p><h5 id="Platform">Platform</h5><p>On Android I found that I could readily use the Java runtime classes.  Some, but not all, of the standard Java RT classes are available on Android.  I didn’t find this a problem, since most of the standard Java IO, network and regex libraries are available.  Android RT classes appear to be based on <a href="http://harmony.apache.org/">Harmony</a>, which has been around long enough to be stable. </p><p>With iPhone on the other hand, finding the functionality that I needed was painful.  Classes and methods are poorly organized.  When to look for a static method versus a class with members was not clear to me.  Also depending on the framework used, naming conventions and code organization would differ.  I suppose this is the legacy of an older platform.  Areas where functionality was lacking that I found painful were regular expressions, string handling and XML parsing.  I ended up using the excellent <a href="http://regexkit.sourceforge.net/">Regex Kit Lite</a> for regular expressions. For XML parsing I implemented a parser abstraction over <a href="http://xmlsoft.org/">libxml</a>, only to discover later that I may have had an easier time with <code>NSXMLParser</code> which is a lot more like SAX. </p><p>On the iPhone when things didn’t work as expected I had to resort to Google and hope that others had encountered the same problem.  This technique was hampered by Apple’s earlier NDA policy, which meant that iPhone content is pretty thin on the net.  In some cases I would resort to guesswork and experimentation to find a solution.  </p><p>Android has the benefit of being open source.  Within minutes I had the full Android platform source code on my system, and had re-built the SDK from sources to ensure that the source I had matched the runtime classes in the emulator.  So not only could I see how things were implemented in the Android platform and learn by example, I could step through the platform code in the emulator and discover why my code wasn’t producing the desired results.   </p><p>In general I found the layout, organization, and naming conventions of Android platform classes was consistent and predictable.  This made it much easier to learn.</p><h5 id="ProgrammingModel">Programming Model</h5><p>The iPhone platform does a great job of encouraging an <a href="http://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller">MVC</a> design pattern.  With this design pattern built in to the platform, building the UI was simple and I didn’t have to figure out how to organize the UI component design myself.  It also means that when looking at sample code, it’s all organized in the same way.</p><p>Android also does a good job with design patterns, though their concepts varied significantly from the iPhone.  With Android’s support for multiple processes and component reuse, the platform itself provides support for Intents and Activities (an Intent is just a variant of a <a href="http://en.wikipedia.org/wiki/Command_pattern">command</a>).  The design results in a better user experience, however it does introduce some complexity for the developer:  when starting one Activity from another, an Intent is used to communicate any parameters.  These parameters cannot be passed by reference — only by value.  Where on the iPhone it’s simple to have screens sharing the same data structures, on Android this requires some forethought.  Apparently Android applications can manage the back button and have everything occur inside a single Activity, however this is not the norm. </p><p>Both Android and iPhone provide a way of declaring user preferences in XML.  Both platforms provide a default UI for editing those preferences, which is great.  Android’s XML format is extensible allowing custom UI components to be integrated, which makes user preferences a breeze.  iPhone developers that wish to customize preferences will have to implement a UI from scratch, which is a lot more work.</p><h5 id="TestingandContinuousIntegration">Testing and Continuous Integration</h5><p>I’m of the opinion that every development effort should include unit tests.  Teams of size greater than one should also include <a href="http://en.wikipedia.org/wiki/Continuous_integration">Continuous Integration</a>.</p><p>Android developers will be happy to know that they can write JUnit tests.  I could even launch these from the Eclipse UI after some classpath fiddling.  Though I didn’t try it, I assume that it’s trivial to run these from Ant and your favorite CI server such as <a href="https://hudson.dev.java.net/">Hudson</a>.</p><p>I did see some iPhone unit test documentation with the iPhone SDK but didn’t take the time to explore it — so I can’t comment there.  </p><h4 id="Resources">Resources</h4><p>Apple does an excellent job of providing lots of resources for developers.  Important concepts are explained in videos, which makes grasping concepts easy — however I did find that videos progressed slowly and I was watching for what seemed like hours to find information that should have taken minutes.  Luckily Apple also provides lots of sample applications and code to demonstrate API usage.</p><p>Android developers also have access to loads of resources.  The guide and API reference are installed with the SDK, so everything is available when offline (which for me is important since I do a lot of my work in transit).  I found the Android development resources better organized and spent less time looking and more time finding.  In particular the ApiDemos sample app provides a great starting point.  I also downloaded many open source Android projects for ideas on architecture and API usage.  This is an area where Android has the advantage, with Apple’s previous NDA policy there isn’t much out there in terms of open source for iPhone.</p><h4 id="Tooling">Tooling</h4><p>For me tooling was a real shocker.  These are the categories of tooling that I’ll cover: IDE, UI builder, debugger, profiler.  Almost everything else is related to provisioning, and in that area I didn’t notice much in the way of differences between Android and iPhone.</p><h5 id="IDE">IDE  </h5><p>Android development leverages the excellent <a href="http://www.eclipse.org/jdt">JDT</a> tools, which are pretty much stock and standard with every Eclipse installation.  I’ve used these tools now for many years and they’re excellent.  Everything Java is indexed, the IDE has a rich model of the source code, and refactoring is so seamless that it has changed the way that I work.  </p><p>Perhaps the best feature of JDT is its <a href="http://en.wikipedia.org/wiki/Incremental_compiler">incremental compiler</a>, which provides immediate feedback with errors and warnings as you type.  This eliminates the code-compile-wait-for-feedback cycle that was so common in the '80s and '90s.  Errors and warnings are updated in the Java editor as I type, giving me instant feedback.  I didn’t realize just how valuable this feature is until I was coding Objective-C in XCode — when I became acutely aware at how waiting for compiler feedback can break the flow of programming.   </p><p>Other key features that make Eclipse so amazing to work with are:</p><ul><li>content assist</li><li>quick-fixes</li><li>organize imports</li><li>open type (CTRL+Shift+T)</li><li>refactorings</li></ul><p>Integrated javadoc and content assist is quite possibly the best way to learn an unfamiliar API.  In Ecipse not only are all classes and methods immediately available in the context in which you’re writing code, their documentation is presented alongside.</p><a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://3.bp.blogspot.com/_vw9l2nnub6c/Sk2e-j6p2NI/AAAAAAAAAHU/KzoZ58wkpVY/s1600-h/content-assist-javadoc.png"><img style="display:block; margin:0px auto 10px; text-align:center;cursor:pointer; cursor:hand;width: 400px; height: 58px;" src="/images/blog/2009-07-02/content_assist_javadoc.png" border="0" alt="" id="BLOGGER_PHOTO_ID_5354110329643718866" /></a><p><b>Content Assist with Integrated Javadoc</b></p><p>XCode is so shockingly bad that I almost don’t know where to start.  Here’s a <em>minimum</em> list of things that I think need fixing in order for XCode to become a viable IDE:</p><ul><li>Content assist that actually works.  Content assist provided by XCode is often wrong, and almost always suggests a small subset of what’s actually available.</li><li>A decent window/editor management system.  XCode and it’s associated tools (debugger) like to open lots of windows.  Want to open a file?  How about a new window for you!  Very quickly I found myself in open-window-hell.  The operating system’s window management is designed for managing multiple applications, not multiple editors within an IDE.  It’s simply not capable of providing management of editors in an environment as sophisticated as an IDE.</li><li>A project tree view that sorts files alphabetically.  Really!</li><li>Integrated API documentation.  I found that I was constantly switching out of the IDE and searching for API documentation using <a href="http://homepage.mac.com/aglee/downloads/">Appkido</a>.   This may seem trivial, but it really breaks the flow.</li></ul><p>One area of Eclipse that simply can’t be matched is <a href="http://www.eclipse.org/mylyn">Mylyn</a>.  Integrated task management and a focused interface introduce huge efficiencies into any project, small or large.  If you haven’t yet tried out Mylyn, it’s definitely worth your time to take a look.  A good place to start is Mylyn’s <a href="http://www.eclipse.org/mylyn/start/">Getting Started</a> page.</p><h5 id="UIBuilder">UI Builder</h5><p>iPhone app developers are given a pretty good UI builder.  It does a great job of showing the UI as it will actually appear.  It’s flexible and can model some pretty sophisticated UIs, so I was impressed.   I found that using it was a little tricky — I had to read the documentation two or three times before I could really figure out how to use it properly.</p><p>The Android UI builder I found pretty useless: it can’t display UIs how they’ll actually appear, and it’s UI is way too inefficient.  I found that I coded all of the UIs directly in the XML source view of the UI builder.  There the content assist and validation were pretty good, making it the easiest way for me to build a UI.</p><h5 id="Debugger">Debugger</h5><p>Having used to the Java debugger in Eclipse I was shocked at the state of the debugger in XCode.  With Eclipse I can see and modify variable values.  Not so in XCode.  Maybe this is simply the state of affairs when debugging native code, but it sure affects the usefulness of the debugger.  XCode often seemed confused as to the type of an object and presented me with a pointer value and no detail.  This is a sharp contrast to Eclipse, where I can drill down through an object graph with ease.</p><p>I found the XCode debugger UI extremely difficult to use.  Clicking on the stack to show code in an editor caused new windows to open, eventually resulting in dozens of windows open.  In addition I found that watch expressions rarely worked for me. </p><h5 id="ProfilerandHeapAnalysis">Profiler and Heap Analysis</h5><p>An area where Apple development tools excel is in profiling and heap analysis.  These tools seemed mature and easy to use.  With no prior experience with these specific tools I was able to gain a better understanding of my app within minutes, find and fix several memory leaks and improve performance.</p><a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://1.bp.blogspot.com/_vw9l2nnub6c/Sk2fRWSUpAI/AAAAAAAAAHc/CEptOHGaX48/s1600-h/memory-analysis.png"><img style="display:block; margin:0px auto 10px; text-align:center;cursor:pointer; cursor:hand;width: 400px; height: 225px;" src="/images/blog/2009-07-02/memory_analysis.png" border="0" alt="" id="BLOGGER_PHOTO_ID_5354110652402410498" /></a><p><b>XCode Memory Leak Detection</b></p><p>Android developers must use Android’s traceview application, which I found worked well but required significantly more effort to configure and operate.  I was surprised to find that the source code must be changed in order to get the trace files required for analysis.</p><p>I’m not sure if Android can provide heap dumps in hprof format.  If it can then the awesome <a href="http://www.eclipse.org/mat/">MAT</a> tool could be used to analyze heap usage.  According to <a href="http://discuz-android.blogspot.com/2009/06/android-memory-usage-with-hprof.html">this article</a> Android <em>can</em> produce hprof heap data, though I haven’t tried it.</p><h4 id="AppStore">App Store</h4><p>It goes without saying that the iPhone app store is excellent in that you can sell into many countries worldwide with a single setup.  I was able to provide my Canadian bank account number, sign a few legal agreements and I was up and running.  </p><p>Getting an app into the store however is frustrating to say the least.  Apple must approve every app before it is accepted into the store.  Mine got rejected multiple times.  Each time it was rejected I was given <em>almost</em> no information about why.  When I emailed them to clarify the problem, I received what looked like a canned response indicating that I should refer to previous correspondence.  If it weren’t so frustrating I would have found it funny.  I highly recommend reading Brian Stormont’s <a href="http://www.mobileorchard.com/avoiding-iphone-app-rejection-from-apple/">Avoiding iPhone App Rejection from Apple</a> and Dan Grigsby’s <a href="http://www.mobileorchard.com/avoiding-iphone-app-rejection-part-2/">Part 2</a> follow-up. </p><p>Of course once I started selling Hudson Helper I realized that Apple won’t send me any money unless the payout is greater than $250.  This is true not only of the first payout, but every payout.  Google market on the other hand requires a minimum of $1 for each payout.  Both the iPhone app store and Google market take about %30 of your app selling price.  $0.99 applications have to have high volume, or they’re simply not worth your time. </p><p>The Google market by comparison to the Apple app store is terrible in that you can only sell into a <a href="http://market.android.com/support/bin/answer.py?hl=en&amp;answer=138294">handful of countries</a>.  You also can’t see or install apps that cost money on a developer phone.  Actually you can, but not if the app has copy protection — which is almost every non-free app.  On the other hand when you upload your app to the app store it’s available within minutes, so you don’t have to worry about an approval process.</p><p>To set up a merchant account with Google market, I had to provide a US address and bank account number, since Google doesn’t support Canada.  For me this was a pain, but not too bad since I live within a few kilometers of the US border.  I rode my bike down to the US and opened an account with Horizon bank.  The bank required a passport and driver’s license, so no problem there.  Why Google doesn’t support more countries I don’t know.  At the very least Google market should accept alternate payment methods for countries that are not supported by Google checkout.</p><h4 id="Summary">Summary</h4><p>Android’s platform and developer tools are excellent.  Leveraging Java and the Eclipse IDE are major winning factors for Android.  Apple’s developer tools are shockingly bad by comparison.  The Objective-C language and platform APIs are cumbersome and poorly organized.  Overall when developing for the iPhone I felt like I was back in 1993.  These factors combined in my estimation make application development about three times more expensive when developing for iPhone.  The only area where Apple’s developer tools excelled was in profiling and heap analysis.</p><p>Apple’s app store from a user’s standpoint and from a worldwide coverage standpoint are excellent.  In this area Google market for Android is weak.</p><p>Development for iPhone may improve as tools such as <a href="http://code.google.com/p/iphonical/">iphonical</a> (MDD for iPhone) and <a href="http://code.google.com/p/objectiveclipse/">objectiveclipse</a> (Eclipse plug-in for Objective-C) emerge.</p><p>We may see a shake-up in the mobile market, with at least 18 new Android handsets being released this year.  Until that happens, iPhone will remain a market leader and developers will have to put up with XCode and Objective-C.</p><p>For me, my love is with Android.  Sure, the iPhone is great — but can you install a new Linux kernel?</p>
